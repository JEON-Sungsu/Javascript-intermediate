# 자바스크립트 심화 강의 내용 정리

## this keyword 

<b>this 는 3~4가지 뜻이 있음.</b>

1. this 값이 window를 가리킬때 
    - 아무것도 없이 그냥 this 만 사용할 때
    - 함수 정의할때, 함수 안에서 그냥 this만 쓸 때.
    - 이 window가 뭐냐면, 우리가 전역으로 변수나 함수같은것을 만들면 자동으로 브라우저에서 이것들을 {} 객체안에 넣어주게 된다. 따로 파일에 {} 넣지 않지만, 저 안에 우리가 전역으로 만든것들이 들어가있다고 보면 되는거고, window 는 저것을 지칭하게 되는것이다. (글로벌 오브젝트라고도 한다)
2. 객체안에서의 this
    - 객체 안에서 메소드를 쓸때 이때의 this는 해당 함수를 포함하고 있는 object 자체를 의미하게된다.
    ```
    let obj = {
        함수 : function() {
            console.log(this)
        }
    }

    obj.함수(); //객체 함수 호출방법 
    ```
    - 객체 안에 객체를 넣었을 때
    ```
    let obj = {
        data : {
            함수: function(){
                console.log(this)
            }
        }
    }

    obj.data.함수(); // data 객체 자체를 반환한다. 
    ```

    - 객체 안에서 함수를 쓸 때는 
    ```
    let obj = {
        data : 함수명(){

        }
    }

    function 키워드를 안써줘도 된다. 그냥 함수 이름만 지어도 됨.
    ```

    - Arrow function 안에서의 this 는 window를 가리킴.
    - Arrow function은 바로 직전 상위코드에서 사용된 this(어디에 붙어있는 this던 간에)를 불러오게 된다. 상위 코드에서 this가 없을 경우에는 최상위인 window를 가리키게 된다.

3. Constructor ( 오브젝트 생성 기계)
    - 함수로 만드는 오브젝트 생성 기계 
    ```
    function test(){
        this.이름 = "kim",
    }

    함수안에서 this 를 사용하면 새로 생성되는 객체를 뜻함. 그리고 이것을 instance 라고 한다.

    const obj = new test(); //이렇게 하면 오브젝트가 생성이됨.
    ```

4. 이벤트 리쓰너 
    - this = e.currentTarget 과 동일하다. 지금 이벤트가 동작하고 있는 요소를 지칭해준다.

5. 예외 케이스
    - 콜백 함수 -> 1번케이스가 나온다. window가 받는다. 
    ```
    button.addEventListener('click',function(){
        var arr = [1,2,3];

        arr.forEach(function(item){
            console.log(this); //window {~~~}
        })
    })
    ```
    <br><br>
    
    - 객체내부의 콜백함수에서 this = window{~~~} 가 된다.
    - 객체내부의 콜백말고 함수에서 this = obj 출력
    - 객체내부의 콜백자리에 에로우 펑션을 쓰게 된다면 바로 직전에 사용된 this를 출력한다. 아래의 구조에서 에로우 펑션에 this 를 사용하게 되면, 그 위의 콘솔로그에 있는 this를 뽑아오게 되고 //obj 를 출력하게 된다. 
    ```
    let obj = {
        name : "kim",
        age : 34,
        gender : ['male', 'female'],
        ft : function() {
            console.log(this) //obj 출력
            obj.gender.forEach(function(item){
                console.log(this); //window 출력
            })
        }
    }

    obj.ft();
    ```




## 'use strict'

- 스크립트 파일 최상단에 'use strict'를 적어두면 아주 엄격한 스크립트만 사용해야한다.

<br><br>

## Arrow Function

1. 함수를 만드는 방법
    - function() {} //기본
    - const something = function(){} //변수에 담아서
    - () => {} //에로우 펑션
2. 에로우 펑션의 장점 
    - 입출력용 펑션을 만들때 보기 쉬움
    - 파라미터가 1개밖에 없을 때는 소괄호를 생략할 수 있다.
    ```
    a = > {return a + 10}
    ```
    - 리턴도 한줄이면 중괄호도 생략 가능
    ```
    a = >  a + 10
    ```
3. 사용 예시 
    - 배열 each문에서의 콜백함수
    ```
    const arr =[1,2,3,4,5]

    arr.forEach((a) => {

    })
    ```
    - 이벤트 리스너에서으 콜백함수
    - 객체내 메소드에서
    - 객체내 메소드의 콜백함수로 

<br><br>

## 변수

- 변수는 자료를 임시 저장하기 위해 사용하는 것임
- var, let, const 3가지 키워드가 있다.
- 변수는 선언,할당,범위 등의 특성이 있다.
    ```
    let 변수 //선언 = 키워드를 사용해서 변수를 만들어준다.
    let 변수 = "저장할자료내용" //할당
    변수 = "바꿀 자료 내용" //재할당 
    ```
- var 는 재선언, 재할당 이 가능하다. 
- let 은 변수에 할당된 값을 변경할 수 있다. 재선언은 불가.
- const 는 변수에 할당된 값을 변경할 수 없다. 재선언도 불가.
    - const로 객체나 배열은 내부 자료의 값을 변경하는것은 괜찮다. 다만 오브젝트를 배열로, 배열을 오브젝트로 등 큰 틀을 바꾸진 못한다.
    - 아에 변경이 불가능한 오브젝트를 만들고 싶으면
    ```
    const obj = {
        이름 : "전성수"
    }

    Object.freeze(obj) //obj의 값들을 변경할 수 없음.
    ```
- 모든 변수는 활용이 가능한 범위가 존재한다.
    - 함수,if문 기타 등등의 내부에서 선언한 변수는 함수 내부에서만 사용할 수 있다.
    ```
    function 함수(){
        var 이름 = "전성수"
    }

    console.log(이름) // 에러남. 함수 밖에서 함수 내부의 변수를 호출해서.
    ```
    - let,const 의 범위는 모든 중괄호 내이다.
- 변수 Hoisting (호이스팅) 현상
    - 변수의 선언을 변수 범위 맨 위로 끌고오는현상(페이지의 제일 하단에 선언하더라도, 제일 상단에서 선언한것처럼 나타내준다)
    - 단, 선언만 호이스팅되지, 할당된 값들이 호이스팅되지는 않는다.
    - 원래 자바스크립트는 제일 위에서 아래로 쭉 읽어나간다. 그래서 아래쪽에 선언한 변수를 위에서 사용하려면 에러가 나는게 정상이다.
    ```
    console.log(변수) //에러

    let 변수 = "Hi"
    ```
    - 하지만 var 키워드를 사용해서 변수를 선언하면, 위의 상황에서도 console.log 가 잘 출력된다. 이게 호이스팅 현상이다. 

- 변수를 여러개 만들기
    - var 나이 = 20, 이름 = '전성수', 성별; (var,let,const 다됨)

- 전역변수
    - 모든곳에서 쓸 수 있는 변수. 
    - 스크립트 파일 제일 바깥에 선언된 변수임.
    - 전역변수의 반대말은 지역변수이다. 지역변수는 함수든 뭐든 {}안에 선언된 변수이다. 
    - 전역변수를 만들때 window.변수명 = "값"; 이렇게 많이 사용한다. 

- for 문에서 var 키워드로 setTimeout을 여러번 돌릴때 동작안하는 이유
    ```
    for(var i = 1; i < 5; i++){
        setTimeout(function(){
            console.log(i);
        },i * 1000);
    }

    let 으로 바꾸면 잘 동작함.
    var 가 안되는 이유는, setTimeout은 코드가 실행되고 몇초 후에 진행이 되는데, for문은 코드가 돌자마자 0.몇초반에 정해진 횟수를 다 돌아버린다. 이후에 우리 눈에는 따로 보이지 않지만, var i = 5; 라는 형태로 for문 외부에 전역변수의 형태로 따로 저장되어진다. 그래서 setTimeout 에 있는 i 는 외부에 전역변수로 선언된것처럼 된 i 를 가져와서 계속해서 5만 반복해서 출력하게 된다. 
    let 은 중괄호 밖으로 나가지 않음으로 잘됨 솔직히 잘 이해가 안가긴 하는데 그냥 그런가보다 함.
    ```


## template literal
- 문자열
- 백틱을 사용하는 ES6문법중 하나임. 
- 장점은 백틱안에서 문자를 작성할때는 엔터키를 적용시킬 수 있고, ${}를 통해 변수같은것을 집어넣기 편해짐. 
- 원래 스크립트에서 변수나 문자를 합치려면 + 기호를 사용해서 문자사용했었음
```
const 문자 = '안녕하세요' + 변수 + '입니다'; //기존
const 문자 = `안녕하세요 ${변수}입니다.`;  //백틱사용

const html = '<div>' +
                '<span>' +
                '</span>' +
            '</div>'
//기존

const html = `<div>
                <span>
                </span>
            </div>`
//백틱사용
```
- tagged Literal (별로 사용되진않고, 중요하진않음. 이런게 있다~)
    - 함수를 호출할때, 소괄호 대신 백틱을 넣어서 사용해도 된다.
    ```
    let 변수 = "전성수"
    let 문자 = `하이 ${변수}입니다.`
    function 해체분석기(문자들,변수들){
        console.log(문자들);
        console.log(변수들);
    }

    해체분석기`하이 ${변수}입니다.`
    //["하이","입니다"]
    //전성수 
    ```
    - 문자를 해체해서 나눌 수 있음.
    - 함수호출할때 백틱을 사용해서 위의 내용을 넣으면, 첫번째 파라미터로 백틱내용중 문자들을 배열에 담아서 반환하고, 두번쨰 파라미터에서 해당 백틱안 내용중 변수가 있으면 그걸 뽑아서 보여준다. 

## Spread Operator
- ... 쩜 세개를 사용하는 연산자이다. 뭔가를 쭉 늘어놓고싶을때 사용하는 연산자이다.
- 용도
    1. Array에 붙이면 대괄호를 제거해준다.
        ```
        const arr = [1,2,3,4,5]

        console.log(...arr) // 1,2,3,4,5 
        ```
    2. 문자를 나눠준다
        ```
        const 문자 = "hello"

        console.log(...문자) //h e l l o
        => console.log('h','e','l','l','o');
        ```
        - 참고로 문자는 배열처럼 인덱싱이 가능함
        ```
        console.log(문자[1]) //e
        ```

- 어디에다 쓸수있냐 (배열,객체를 합치거나 복사할때 쓴다.)
```
const a = [1,2,3];
const b = [4,5];

const c = [...a]; 
const d = [...a, ...b];
console.log(c) // [1,2,3] //어레이 복사
console.log(d) // [1,2,3,4,5] //어레이 합치기
```

- 배열을 Deep copy 할때 굉장히 유용하고 많이 사용되어진다. 
- Deep copy 란? (배열,객체 합치기)
    - 일반적으로 배열을 복사할때
    ```
    const a = [1,2,3];
    const b = a; 

    이렇게 사용하는데, 만약 이렇게 했을때 만약 a 의 값을 변경하면 b도 같이 변경되어버린다.
    b 를 다른용도로 사용하려고 했는데 이러면 문제가 되는거지.

    그래서

    const b = [...a];

    로 spread operator 를 사용해야 된다. 

    //합치기
    const obj1 = {a : 1, b : 2,};
    const obj2 = {...obj1, c : 3};

    console.log(obj2)// {a : 1, b : 2, c : 3};

    //복사하기
    const obj2 = {...obj1};

    ```
    - 만약 오브젝트를 합칠때, 오브젝트내에 같은 값이 있으면 같은 값 중 뒤에있는것만 남기고 앞에있는건 삭제해버림
    ```
    const obj1 = {a : 1, b : 2,};
    const obj2 = {...obj1, a : 3};

    console.log(obj2)// {a : 3, b : 2};
    ```

- spread operator 는 항상 중괄호, 대괄호 안에서만 사용가능하다. 밖에다 그냥 사용하면 적용 안된다.

- spread operator 함수의 파라미터에 사용할때
```
const obj1 = {a : 1, b : 2,};
const obj2 = {...obj1, c : 3};

function 더하기(a,b,c){
    return a+b+c;
}

const arr = [1,2,3]
더하기(arr[0],arr[1],arr[2])

일반적으로 위 처럼 사용해야되는게 일반적이다. 
그래서 예전에는

더하기.apply(undefined, arr);
이렇게 사용했었다. 

다만 ... 을 사용하게 되면 
더하기(...arr);
이렇게만 사용해주면 된다. ...을 사용하면 대괄호를 벗기니 출력하게되면 1,2,3 이 남게되기 떄문에 자동으로 파라미터에 알맞게 들어감.

```

- apply함수 (중요하진 않지만 알고있으면 된다)
    - 옛날 스크립트 메서드이다.
    - 

## 함수 업그레이드 
- JS 특징이 함수에 파라미터를 두개 넣어놔도 호출할떄 파라미터 1개만 넣어도 에러가 나지 않음. 
- 함수의 default 파라미터
    - 함수에 파라미터를 2개넣어놔도, 호출할때 1개만 넣는다면 기본적으로 나머지 1개를 자동으로 채워줄 수 있는 방식
    - 파라미터 자리에 = 으로 구분해서 값을 넣어두면, 호출시 두번째 파라미터를 입력안하면 자동으로 10을 b에 넣어주게 된다.
        - 연산자 사용 가능
        - 또다른 함수를 넣을 수 도 있음
    ```
    function sum(a,b = 10){
        console.log(a + b)
    }

    sum(1) // 11

    디폴트 파라미터에는 연산자를 써서 넣을 수 도 있음.

    function sum(a,b = 2 * a){
        console.log(a + b)
    }

    sum(1) // 3 

    함수도 넣을 수 있다. 

    function test() {
        return 10
    }

    function sum(a,b = test()){
        console.log(a + b)
    }

    sum(1) // 11;
    ```
<br><br>

- 함수의 arguments (파라미터,인자,아규먼트 엄밀히 따지면 다른데, 같은말임..)
- 함수내부에 사용하는 arguments 키워드는, 모든 파라미터를 배열에 담아주는 변수이다.(스크립트 기본기능? 그런거임)
```
function 함수 (a,b,c){
    console.log(arguments)
}

함수(1,2,3) // array[1,2,3]

이게 무슨 뜻이냐면 결국

function 함수 (a,b,c){
    console.log(a)
    console.log(b)
    console.log(c)
}

이것과 동일한거다. 
```
- argument 는 근데 옛날 문법이다. arguments 는 모든 파라미터를 다 받기 때문에, 내가 만약 뭐 하나 빼고 특정 파라미터들만 사용하고 싶을때 이걸 나누기가 힘들다. 그래서 나온게 rest 사용법

<br><br>

- ...rest 
- 파라미터자리에 들어온 모든 값들을 배열로 묶어서 사용하겠다. 
- argument와 다른점은, 보관할것들을 특정할 수 있다. 
- 사용법은 함수를 선언할 때 파라미터 자리에 spread operator 를 넣어주면 되는데, 실제 spread operator 와는 다른것이니까 주의해야 한다. 함수에서 파라미터 자리에 ... 쓸때만 rest 임 
- rest 는 함수를 선언할 때 모든 파라미터의 가장 뒤에 넣어줘야 한다.
- 그리고 2번이상 못넣는다. 
```
function 함수2(...파라미터들) {
    console.log(파라미터들)
}

함수2(1,2,3,4,5,6,7,8,10) //array[1,2,3,4,5,6,7,8,10]


function 함수2(a,b, ...파라미터들) {
    console.log(파라미터들)
}

함수2(1,2,3,4,5) // array[3,4,5]

앞의 a 와 b 는 따로, 그 뒤에 오는 나머지는 묶어서 사용한다.
```

```
function 함수2(...파라미터들) {
    for(let i = 0; i < 파라미터들.length; i++){
        console.log(파라미터들[i]);
    }
}

함수2(34,2,542,524,5)
```